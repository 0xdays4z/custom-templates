/**
 * Automated Vulnerability Scanner
 * Validates all discovered vulnerabilities across Porsche JavaScript infrastructure
 * Provides comprehensive testing framework for security assessment
 */

class AutomatedVulnerabilityScanner {
    constructor() {
        this.scannerId = 'VULN_SCANNER_' + Date.now();
        this.reportEndpoint = 'https://security-team.porsche.com/vulnerability-reports';
        this.vulnerabilityTests = [];
        this.scanResults = [];
        this.criticalFindings = [];
        this.testConfig = {
            timeout: 5000,
            retries: 3,
            concurrent: false,
            verbose: true
        };
    }

    /**
     * Initialize vulnerability test suite
     */
    initializeTestSuite() {
        console.log('[VULN SCANNER] Initializing comprehensive vulnerability test suite');

        // Register all vulnerability tests
        this.registerHTMLSanitizationTests();
        this.registerBlobURLTests();
        this.registerScriptInjectionTests();
        this.registerAuthenticationTests();
        this.registerPaymentSystemTests();
        this.registerMobileAppTests();
        this.registerAPISecurityTests();
        this.registerSupplyChainTests();

        console.log(`[VULN SCANNER] Registered ${this.vulnerabilityTests.length} vulnerability tests`);
    }

    /**
     * Register HTML Sanitization Bypass Tests
     */
    registerHTMLSanitizationTests() {
        const htmlSanitizationTests = [
            {
                id: 'HTML_SANITIZATION_001',
                name: 'Wildcard Attribute XSS',
                severity: 'critical',
                category: 'xss',
                description: 'Test for HTML sanitization bypass via wildcard attributes',
                test: async () => {
                    return this.testWildcardAttributeXSS();
                }
            },
            {
                id: 'HTML_SANITIZATION_002',
                name: 'Data Attribute Code Execution',
                severity: 'critical',
                category: 'xss',
                description: 'Test for code execution via data attributes',
                test: async () => {
                    return this.testDataAttributeExecution();
                }
            },
            {
                id: 'HTML_SANITIZATION_003',
                name: 'Event Handler Injection',
                severity: 'high',
                category: 'xss',
                description: 'Test for event handler injection bypass',
                test: async () => {
                    return this.testEventHandlerInjection();
                }
            },
            {
                id: 'HTML_SANITIZATION_004',
                name: 'AllowVulnerableTags Configuration',
                severity: 'critical',
                category: 'configuration',
                description: 'Test for dangerous allowVulnerableTags configuration',
                test: async () => {
                    return this.testAllowVulnerableTagsConfig();
                }
            }
        ];

        this.vulnerabilityTests.push(...htmlSanitizationTests);
    }

    /**
     * Test wildcard attribute XSS vulnerability
     */
    async testWildcardAttributeXSS() {
        console.log('[VULN SCANNER] Testing wildcard attribute XSS');

        const testPayloads = [
            '<div data-payload="alert(\'XSS\')" onmouseover="eval(this.getAttribute(\'data-payload\'))">Test</div>',
            '<img data-src="x" data-onerror="alert(\'XSS\')" onerror="eval(this.getAttribute(\'data-onerror\'))">',
            '<span data-code="YWxlcnQoJ1hTUycpOw==" onclick="eval(atob(this.getAttribute(\'data-code\')))">Click</span>'
        ];

        const results = [];

        for (const payload of testPayloads) {
            try {
                // Create test element
                const testContainer = document.createElement('div');
                testContainer.innerHTML = payload;
                document.body.appendChild(testContainer);

                // Check if payload was sanitized
                const isSanitized = !testContainer.innerHTML.includes('onmouseover') && 
                                   !testContainer.innerHTML.includes('onerror') && 
                                   !testContainer.innerHTML.includes('onclick');

                results.push({
                    payload: payload,
                    sanitized: isSanitized,
                    vulnerable: !isSanitized,
                    element_html: testContainer.innerHTML
                });

                // Clean up
                document.body.removeChild(testContainer);

            } catch (e) {
                results.push({
                    payload: payload,
                    error: e.message,
                    vulnerable: false
                });
            }
        }

        const vulnerablePayloads = results.filter(r => r.vulnerable);
        
        return {
            vulnerable: vulnerablePayloads.length > 0,
            severity: vulnerablePayloads.length > 0 ? 'critical' : 'safe',
            details: {
                total_payloads: testPayloads.length,
                vulnerable_payloads: vulnerablePayloads.length,
                results: results
            },
            recommendation: vulnerablePayloads.length > 0 ? 
                'Implement strict HTML sanitization without wildcard attribute matching' : 
                'HTML sanitization appears to be working correctly'
        };
    }

    /**
     * Test data attribute code execution
     */
    async testDataAttributeExecution() {
        console.log('[VULN SCANNER] Testing data attribute code execution');

        const testPayloads = [
            {
                html: '<div data-config="eyJhZG1pbiI6dHJ1ZX0=" data-execute="true">Test</div>',
                script: 'document.querySelector("[data-execute]").onclick = function() { eval(atob(this.getAttribute("data-config"))); };'
            },
            {
                html: '<span data-payload-code="Y29uc29sZS5sb2coJ1Z1bG5lcmFibGUnKTs=" data-auto-exec="true">Auto Execute</span>',
                script: 'document.querySelector("[data-auto-exec]").onload = function() { eval(atob(this.getAttribute("data-payload-code"))); };'
            }
        ];

        const results = [];

        for (const test of testPayloads) {
            try {
                // Create test element
                const testContainer = document.createElement('div');
                testContainer.innerHTML = test.html;
                document.body.appendChild(testContainer);

                // Try to execute the script
                const scriptElement = document.createElement('script');
                scriptElement.textContent = test.script;
                document.head.appendChild(scriptElement);

                // Check if data attributes are preserved
                const hasDataAttributes = testContainer.innerHTML.includes('data-config') || 
                                         testContainer.innerHTML.includes('data-payload-code');

                results.push({
                    test: test,
                    data_attributes_preserved: hasDataAttributes,
                    vulnerable: hasDataAttributes,
                    element_html: testContainer.innerHTML
                });

                // Clean up
                document.body.removeChild(testContainer);
                document.head.removeChild(scriptElement);

            } catch (e) {
                results.push({
                    test: test,
                    error: e.message,
                    vulnerable: false
                });
            }
        }

        const vulnerableTests = results.filter(r => r.vulnerable);

        return {
            vulnerable: vulnerableTests.length > 0,
            severity: vulnerableTests.length > 0 ? 'critical' : 'safe',
            details: {
                total_tests: testPayloads.length,
                vulnerable_tests: vulnerableTests.length,
                results: results
            }
        };
    }

    /**
     * Register Blob URL Tests
     */
    registerBlobURLTests() {
        const blobURLTests = [
            {
                id: 'BLOB_URL_001',
                name: 'JavaScript Blob URL Creation',
                severity: 'critical',
                category: 'code_injection',
                description: 'Test for unsafe JavaScript blob URL creation',
                test: async () => {
                    return this.testJavaScriptBlobCreation();
                }
            },
            {
                id: 'BLOB_URL_002',
                name: 'SourceMap URL Manipulation',
                severity: 'high',
                category: 'code_injection',
                description: 'Test for sourceMappingURL manipulation in blobs',
                test: async () => {
                    return this.testSourceMapManipulation();
                }
            },
            {
                id: 'BLOB_URL_003',
                name: 'Auth0 Blob Vulnerability',
                severity: 'critical',
                category: 'authentication',
                description: 'Test for Auth0 blob URL vulnerability',
                test: async () => {
                    return this.testAuth0BlobVulnerability();
                }
            }
        ];

        this.vulnerabilityTests.push(...blobURLTests);
    }

    /**
     * Test JavaScript blob URL creation vulnerability
     */
    async testJavaScriptBlobCreation() {
        console.log('[VULN SCANNER] Testing JavaScript blob URL creation');

        const testCases = [
            {
                name: 'Direct JavaScript Blob',
                code: 'alert("Blob XSS Test");',
                mimeType: 'application/javascript'
            },
            {
                name: 'Malicious SourceMap',
                code: 'console.log("test");\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV2aWwuanMiXX0=',
                mimeType: 'application/javascript'
            },
            {
                name: 'Auth Token Injection',
                code: 'localStorage.setItem("auth0.access_token", "FAKE_ADMIN_TOKEN");',
                mimeType: 'application/javascript'
            }
        ];

        const results = [];

        for (const testCase of testCases) {
            try {
                // Test if blob creation is allowed
                const blob = new Blob([testCase.code], { type: testCase.mimeType });
                const blobURL = URL.createObjectURL(blob);

                // Check if blob URL was created successfully
                const blobCreated = blobURL.startsWith('blob:');

                results.push({
                    test_case: testCase.name,
                    blob_created: blobCreated,
                    blob_url: blobURL,
                    vulnerable: blobCreated && testCase.mimeType === 'application/javascript',
                    mime_type: testCase.mimeType
                });

                // Clean up
                URL.revokeObjectURL(blobURL);

            } catch (e) {
                results.push({
                    test_case: testCase.name,
                    error: e.message,
                    vulnerable: false,
                    blocked: true
                });
            }
        }

        const vulnerableTests = results.filter(r => r.vulnerable);

        return {
            vulnerable: vulnerableTests.length > 0,
            severity: vulnerableTests.length > 0 ? 'critical' : 'safe',
            details: {
                total_tests: testCases.length,
                vulnerable_tests: vulnerableTests.length,
                results: results
            },
            recommendation: vulnerableTests.length > 0 ? 
                'Block JavaScript blob URL creation or implement strict validation' : 
                'Blob URL creation appears to be properly restricted'
        };
    }

    /**
     * Register Authentication Tests
     */
    registerAuthenticationTests() {
        const authTests = [
            {
                id: 'AUTH_001',
                name: 'JWT Token Manipulation',
                severity: 'critical',
                category: 'authentication',
                description: 'Test for JWT token manipulation vulnerabilities',
                test: async () => {
                    return this.testJWTTokenManipulation();
                }
            },
            {
                id: 'AUTH_002',
                name: 'LocalStorage Token Injection',
                severity: 'high',
                category: 'authentication',
                description: 'Test for localStorage token injection',
                test: async () => {
                    return this.testLocalStorageTokenInjection();
                }
            },
            {
                id: 'AUTH_003',
                name: 'Admin Privilege Escalation',
                severity: 'critical',
                category: 'authorization',
                description: 'Test for admin privilege escalation',
                test: async () => {
                    return this.testAdminPrivilegeEscalation();
                }
            }
        ];

        this.vulnerabilityTests.push(...authTests);
    }

    /**
     * Test JWT token manipulation
     */
    async testJWTTokenManipulation() {
        console.log('[VULN SCANNER] Testing JWT token manipulation');

        // Create test JWT tokens
        const testTokens = [
            {
                name: 'Admin Role Injection',
                payload: {
                    sub: 'test_user',
                    roles: ['admin', 'super_admin'],
                    permissions: ['*'],
                    iat: Math.floor(Date.now() / 1000),
                    exp: Math.floor(Date.now() / 1000) + 3600
                }
            },
            {
                name: 'Extended Expiry',
                payload: {
                    sub: 'test_user',
                    exp: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60) // 1 year
                }
            },
            {
                name: 'Bypass Restrictions',
                payload: {
                    sub: 'test_user',
                    bypass_all_restrictions: true,
                    admin: true,
                    system_access: true
                }
            }
        ];

        const results = [];

        for (const tokenTest of testTokens) {
            try {
                // Create fake JWT
                const header = { typ: 'JWT', alg: 'HS256' };
                const encodedHeader = btoa(JSON.stringify(header));
                const encodedPayload = btoa(JSON.stringify(tokenTest.payload));
                const fakeSignature = 'FAKE_SIGNATURE_TEST';
                
                const fakeJWT = `${encodedHeader}.${encodedPayload}.${fakeSignature}`;

                // Test if token can be stored
                const originalToken = localStorage.getItem('auth0.access_token');
                localStorage.setItem('auth0.access_token', fakeJWT);
                
                // Verify token was stored
                const storedToken = localStorage.getItem('auth0.access_token');
                const tokenStored = storedToken === fakeJWT;

                // Try to decode stored token
                let decodedPayload = null;
                if (tokenStored) {
                    try {
                        const parts = storedToken.split('.');
                        decodedPayload = JSON.parse(atob(parts[1]));
                    } catch (e) {
                        // Token decode failed
                    }
                }

                results.push({
                    test_name: tokenTest.name,
                    token_stored: tokenStored,
                    payload_decoded: !!decodedPayload,
                    decoded_payload: decodedPayload,
                    vulnerable: tokenStored,
                    fake_jwt: fakeJWT.substring(0, 100) + '...' // Truncate for logging
                });

                // Restore original token
                if (originalToken) {
                    localStorage.setItem('auth0.access_token', originalToken);
                } else {
                    localStorage.removeItem('auth0.access_token');
                }

            } catch (e) {
                results.push({
                    test_name: tokenTest.name,
                    error: e.message,
                    vulnerable: false
                });
            }
        }

        const vulnerableTests = results.filter(r => r.vulnerable);

        return {
            vulnerable: vulnerableTests.length > 0,
            severity: vulnerableTests.length > 0 ? 'critical' : 'safe',
            details: {
                total_tests: testTokens.length,
                vulnerable_tests: vulnerableTests.length,
                results: results
            }
        };
    }

    /**
     * Register Payment System Tests
     */
    registerPaymentSystemTests() {
        const paymentTests = [
            {
                id: 'PAYMENT_001',
                name: 'Payment API Interception',
                severity: 'critical',
                category: 'financial',
                description: 'Test for payment API interception capabilities',
                test: async () => {
                    return this.testPaymentAPIInterception();
                }
            },
            {
                id: 'PAYMENT_002',
                name: 'Credit Card Data Exposure',
                severity: 'critical',
                category: 'financial',
                description: 'Test for credit card data exposure in forms',
                test: async () => {
                    return this.testCreditCardDataExposure();
                }
            },
            {
                id: 'PAYMENT_003',
                name: 'Transaction Amount Manipulation',
                severity: 'high',
                category: 'financial',
                description: 'Test for transaction amount manipulation',
                test: async () => {
                    return this.testTransactionAmountManipulation();
                }
            }
        ];

        this.vulnerabilityTests.push(...paymentTests);
    }

    /**
     * Test payment API interception
     */
    async testPaymentAPIInterception() {
        console.log('[VULN SCANNER] Testing payment API interception');

        const paymentAPIs = [
            '/api/payment/process',
            '/api/billing/charge',
            '/api/transactions/create',
            '/api/wallet/balance'
        ];

        const results = [];
        const interceptedRequests = [];

        // Hook fetch to intercept payment requests
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const [url, options] = args;
            
            if (paymentAPIs.some(api => url.includes(api))) {
                interceptedRequests.push({
                    url: url,
                    method: options?.method || 'GET',
                    headers: options?.headers || {},
                    body: options?.body,
                    timestamp: Date.now()
                });
            }
            
            return originalFetch.apply(this, args);
        };

        // Simulate payment API calls
        for (const api of paymentAPIs) {
            try {
                await fetch(window.location.origin + api, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer test_token'
                    },
                    body: JSON.stringify({
                        amount: 100.00,
                        currency: 'USD',
                        card_number: '4111111111111111'
                    })
                });
            } catch (e) {
                // API might not exist, but we're testing interception
            }
        }

        // Restore original fetch
        window.fetch = originalFetch;

        return {
            vulnerable: interceptedRequests.length > 0,
            severity: interceptedRequests.length > 0 ? 'critical' : 'safe',
            details: {
                intercepted_requests: interceptedRequests.length,
                payment_apis_tested: paymentAPIs.length,
                intercepted_data: interceptedRequests
            },
            recommendation: interceptedRequests.length > 0 ? 
                'Payment API requests can be intercepted - implement request encryption' : 
                'Payment API interception test completed'
        };
    }

    /**
     * Run comprehensive vulnerability scan
     */
    async runComprehensiveScan() {
        console.log('[VULN SCANNER] Starting comprehensive vulnerability scan');
        console.log(`[VULN SCANNER] Total tests to run: ${this.vulnerabilityTests.length}`);

        const startTime = Date.now();
        this.scanResults = [];
        this.criticalFindings = [];

        for (const test of this.vulnerabilityTests) {
            console.log(`[VULN SCANNER] Running test: ${test.id} - ${test.name}`);
            
            try {
                const testStartTime = Date.now();
                const result = await Promise.race([
                    test.test(),
                    this.timeoutPromise(this.testConfig.timeout)
                ]);

                const testDuration = Date.now() - testStartTime;
                
                const testResult = {
                    id: test.id,
                    name: test.name,
                    category: test.category,
                    severity: test.severity,
                    description: test.description,
                    result: result,
                    duration: testDuration,
                    timestamp: Date.now(),
                    status: 'completed'
                };

                this.scanResults.push(testResult);

                // Track critical findings
                if (result.vulnerable && (test.severity === 'critical' || test.severity === 'high')) {
                    this.criticalFindings.push(testResult);
                }

                if (this.testConfig.verbose) {
                    console.log(`[VULN SCANNER] Test ${test.id} completed: ${result.vulnerable ? 'VULNERABLE' : 'SAFE'}`);
                }

            } catch (error) {
                console.error(`[VULN SCANNER] Test ${test.id} failed:`, error.message);
                
                this.scanResults.push({
                    id: test.id,
                    name: test.name,
                    category: test.category,
                    severity: test.severity,
                    description: test.description,
                    error: error.message,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }

            // Small delay between tests to avoid overwhelming the system
            await this.sleep(100);
        }

        const scanDuration = Date.now() - startTime;
        
        console.log(`[VULN SCANNER] Scan completed in ${scanDuration}ms`);
        console.log(`[VULN SCANNER] Critical findings: ${this.criticalFindings.length}`);

        // Generate comprehensive report
        const report = this.generateScanReport(scanDuration);
        
        // Send report to security team
        await this.sendSecurityReport(report);

        return report;
    }

    /**
     * Generate comprehensive scan report
     */
    generateScanReport(scanDuration) {
        const vulnerableTests = this.scanResults.filter(r => r.result?.vulnerable);
        const safeTests = this.scanResults.filter(r => r.result && !r.result.vulnerable);
        const failedTests = this.scanResults.filter(r => r.status === 'failed');

        const severityBreakdown = {
            critical: this.scanResults.filter(r => r.severity === 'critical' && r.result?.vulnerable).length,
            high: this.scanResults.filter(r => r.severity === 'high' && r.result?.vulnerable).length,
            medium: this.scanResults.filter(r => r.severity === 'medium' && r.result?.vulnerable).length,
            low: this.scanResults.filter(r => r.severity === 'low' && r.result?.vulnerable).length
        };

        const categoryBreakdown = {};
        this.scanResults.forEach(result => {
            if (result.result?.vulnerable) {
                categoryBreakdown[result.category] = (categoryBreakdown[result.category] || 0) + 1;
            }
        });

        const report = {
            scan_id: this.scannerId,
            timestamp: Date.now(),
            duration: scanDuration,
            summary: {
                total_tests: this.scanResults.length,
                vulnerable: vulnerableTests.length,
                safe: safeTests.length,
                failed: failedTests.length,
                critical_findings: this.criticalFindings.length
            },
            severity_breakdown: severityBreakdown,
            category_breakdown: categoryBreakdown,
            critical_findings: this.criticalFindings,
            all_results: this.scanResults,
            recommendations: this.generateRecommendations(),
            risk_assessment: this.calculateRiskScore()
        };

        console.log('[VULN SCANNER] Scan Report Generated:', report.summary);
        return report;
    }

    /**
     * Generate security recommendations
     */
    generateRecommendations() {
        const recommendations = [];

        // Check for critical HTML sanitization issues
        const htmlSanitizationIssues = this.criticalFindings.filter(f => f.category === 'xss');
        if (htmlSanitizationIssues.length > 0) {
            recommendations.push({
                priority: 'critical',
                category: 'HTML Sanitization',
                recommendation: 'Implement strict HTML sanitization without wildcard attribute matching',
                affected_tests: htmlSanitizationIssues.map(f => f.id)
            });
        }

        // Check for authentication issues
        const authIssues = this.criticalFindings.filter(f => f.category === 'authentication');
        if (authIssues.length > 0) {
            recommendations.push({
                priority: 'critical',
                category: 'Authentication',
                recommendation: 'Implement proper JWT signature validation and token storage security',
                affected_tests: authIssues.map(f => f.id)
            });
        }

        // Check for code injection issues
        const codeInjectionIssues = this.criticalFindings.filter(f => f.category === 'code_injection');
        if (codeInjectionIssues.length > 0) {
            recommendations.push({
                priority: 'critical',
                category: 'Code Injection',
                recommendation: 'Block JavaScript blob URL creation and implement strict CSP',
                affected_tests: codeInjectionIssues.map(f => f.id)
            });
        }

        return recommendations;
    }

    /**
     * Calculate overall risk score
     */
    calculateRiskScore() {
        const weights = { critical: 10, high: 7, medium: 4, low: 1 };
        let totalScore = 0;

        this.scanResults.forEach(result => {
            if (result.result?.vulnerable) {
                totalScore += weights[result.severity] || 0;
            }
        });

        const maxPossibleScore = this.scanResults.length * weights.critical;
        const riskPercentage = (totalScore / maxPossibleScore) * 100;

        let riskLevel;
        if (riskPercentage >= 70) riskLevel = 'CRITICAL';
        else if (riskPercentage >= 50) riskLevel = 'HIGH';
        else if (riskPercentage >= 30) riskLevel = 'MEDIUM';
        else riskLevel = 'LOW';

        return {
            score: totalScore,
            max_possible: maxPossibleScore,
            percentage: riskPercentage,
            level: riskLevel
        };
    }

    /**
     * Send security report to security team
     */
    async sendSecurityReport(report) {
        try {
            await fetch(this.reportEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Scanner-ID': this.scannerId
                },
                body: JSON.stringify(report)
            });
            console.log('[VULN SCANNER] Security report sent to security team');
        } catch (e) {
            console.log('[VULN SCANNER] Failed to send report, storing locally');
            localStorage.setItem(`vuln_report_${Date.now()}`, JSON.stringify(report));
        }
    }

    /**
     * Utility functions
     */
    timeoutPromise(ms) {
        return new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Test timeout')), ms)
        );
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Execute automated vulnerability scan
     */
    async execute() {
        try {
            console.log('[VULN SCANNER] Starting automated vulnerability assessment');
            
            this.initializeTestSuite();
            const report = await this.runComprehensiveScan();
            
            console.log('[VULN SCANNER] Automated vulnerability assessment completed');
            return report;

        } catch (error) {
            console.error('[VULN SCANNER] Scan execution failed:', error);
            throw error;
        }
    }
}

// Auto-execute if in browser environment
if (typeof window !== 'undefined') {
    const scanner = new AutomatedVulnerabilityScanner();
    scanner.execute().then(report => {
        console.log('[VULN SCANNER] Final Report:', report);
    });
}

// Export for manual execution
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutomatedVulnerabilityScanner;
}